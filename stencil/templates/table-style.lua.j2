{% raw %}
-- Pandoc Lua filter: styled tables with alternating row colors and cell borders.
-- Set min-col-width in document metadata or via --metadata to override the default.
-- Supports side-by-side tables using ::: {.side-by-side} fenced divs.

local MIN_WIDTH = 0.12

local function cell_to_latex(cell)
  local doc = pandoc.Pandoc(cell.contents)
  local result = pandoc.write(doc, 'latex')
  return (result:gsub('%s+$', ''))
end

local function render_table_latex(tbl, use_longtable)
  local ncols = #tbl.colspecs

  -- Enforce minimum column width and redistribute from widest columns.
  local widths = {}
  local has_widths = false
  for i, cs in ipairs(tbl.colspecs) do
    widths[i] = cs[2] or 0
    if widths[i] > 0 then has_widths = true end
  end
  if has_widths then
    local deficit = 0
    local donor_total = 0
    for i = 1, ncols do
      if widths[i] > 0 and widths[i] < MIN_WIDTH then
        deficit = deficit + (MIN_WIDTH - widths[i])
        widths[i] = MIN_WIDTH
      elseif widths[i] > MIN_WIDTH then
        donor_total = donor_total + widths[i]
      end
    end
    if deficit > 0 and donor_total > 0 then
      for i = 1, ncols do
        if widths[i] > MIN_WIDTH then
          widths[i] = widths[i] - deficit * (widths[i] / donor_total)
        end
      end
    end
  end

  -- Build column spec with vertical borders
  local parts = {}
  for i, cs in ipairs(tbl.colspecs) do
    local alignment = cs[1]
    local width = widths[i]
    local part
    if width and width > 0 then
      local align_cmd = '\\raggedright'
      if alignment == pandoc.AlignCenter then
        align_cmd = '\\centering'
      elseif alignment == pandoc.AlignRight then
        align_cmd = '\\raggedleft'
      end
      local w = string.format(
        '(\\linewidth - %d\\tabcolsep - %d\\arrayrulewidth) * \\real{%.4f}',
        2 * ncols, ncols + 1, width
      )
      part = string.format('>{%s\\arraybackslash}p{%s}', align_cmd, w)
    else
      if alignment == pandoc.AlignCenter then part = 'c'
      elseif alignment == pandoc.AlignRight then part = 'r'
      else part = 'l'
      end
    end
    table.insert(parts, part)
  end

  local colspec = '|' .. table.concat(parts, '|') .. '|'

  local lines = {}
  table.insert(lines, '{\\arrayrulecolor{cellborder}')

  if use_longtable then
    table.insert(lines, string.format('\\begin{longtable}[]{%s}', colspec))
  else
    table.insert(lines, string.format('\\begin{tabular}[t]{%s}', colspec))
  end

  -- Top rule: accent color
  table.insert(lines, '\\arrayrulecolor{tableaccent}\\hline')

  -- Header rows
  for _, row in ipairs(tbl.head.rows) do
    table.insert(lines, '\\rowcolor{tableheader}')
    local cells = {}
    for _, cell in ipairs(row.cells) do
      table.insert(cells, cell_to_latex(cell))
    end
    table.insert(lines, table.concat(cells, ' & ') .. ' \\\\')
    table.insert(lines, '\\hline')
  end
  table.insert(lines, '\\arrayrulecolor{cellborder}')

  if use_longtable then
    table.insert(lines, '\\endhead')
  end

  -- Body rows with alternating stripe
  local rownum = 0
  for _, body in ipairs(tbl.bodies) do
    for _, row in ipairs(body.body) do
      rownum = rownum + 1
      if rownum % 2 == 0 then
        table.insert(lines, '\\rowcolor{tablestripe}')
      end
      local cells = {}
      for _, cell in ipairs(row.cells) do
        table.insert(cells, cell_to_latex(cell))
      end
      table.insert(lines, table.concat(cells, ' & ') .. ' \\\\')
      table.insert(lines, '\\hline')
    end
  end

  -- Replace last body \hline with accent-colored bottom rule
  if #lines > 0 and lines[#lines] == '\\hline' then
    lines[#lines] = '\\arrayrulecolor{tableaccent}\\hline'
  end

  if use_longtable then
    table.insert(lines, '\\end{longtable}')
  else
    table.insert(lines, '\\end{tabular}')
  end
  table.insert(lines, '}')

  return table.concat(lines, '\n')
end

return {
  -- First pass: read metadata for configuration.
  { Meta = function(meta)
      if meta['min-col-width'] then
        MIN_WIDTH = tonumber(pandoc.utils.stringify(meta['min-col-width'])) or MIN_WIDTH
      end
    end
  },

  -- Second pass: process side-by-side divs (must come before Table filter).
  { Div = function(div)
      if not FORMAT:match('latex') then return nil end
      if not div.classes:includes('side-by-side') then return nil end

      -- Collect all tables from this div
      local tables = {}
      for _, block in ipairs(div.content) do
        if block.t == 'Table' then
          table.insert(tables, block)
        end
      end

      if #tables == 0 then return nil end

      local latex_parts = {}
      table.insert(latex_parts, '\\begin{center}')

      for i, tbl in ipairs(tables) do
        if i > 1 then
          table.insert(latex_parts, '\\hspace{2em}')  -- fixed gap between tables
        end
        table.insert(latex_parts, '\\begin{minipage}[t]{0.4\\linewidth}')
        table.insert(latex_parts, render_table_latex(tbl, false))
        table.insert(latex_parts, '\\end{minipage}')
      end

      table.insert(latex_parts, '\\end{center}')

      return pandoc.RawBlock('latex', table.concat(latex_parts, '\n'))
    end
  },

  -- Third pass: process standalone tables.
  { Table = function(tbl)
      if not FORMAT:match('latex') then return nil end
      return pandoc.RawBlock('latex', render_table_latex(tbl, true))
    end
  },
}
{% endraw %}
